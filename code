# С клавиатуры вводится два числа K и N.
# Квадратная матрица А(N,N), состоящая из 4-х равных по размерам подматриц, B,C,D,E заполняется случайным образом целыми числами в интервале [-10,10].
# Для тестирования использовать не случайное заполнение, а целенаправленное.

# Вариант 2
# Формируется матрица F следующим образом: если в С количество положительных элементов в четных столбцах в области 2 больше, чем количество отрицательных  элементов в нечетных столбцах в области 4, то поменять в С симметрично области 1 и 3 местами, иначе С и Е поменять местами несимметрично.
# При этом матрица А не меняется. После чего вычисляется выражение: (F+A)*AT – K * F.
# Выводятся по мере формирования А, F и все матричные операции последовательно.
# Вид матрицы A:
# E B
# D C

# Каждая из матриц B,C,D,E имеет вид:    1
#                                      4   2
#                                        3


import random

# Генерация матрицы A и ее подматриц (B, C, D, E)
def generate_matrix(N):
    A = [[0] * N for _ in range(N)]

    # Генерация подматриц B, C, D, E
    for i in range(N):
        for j in range(N):
            # Подматрица B
            if i < N // 2 and j < N // 2:
                A[i][j] = random.randint(-10, 10)
            # Подматрица C
            elif i < N // 2 and j >= N // 2:
                A[i][j] = random.randint(-10, 10)
            # Подматрица D
            elif i >= N // 2 and j < N // 2:
                A[i][j] = random.randint(-10, 10)
            # Подматрица E
            else:
                A[i][j] = random.randint(-10, 10)

    return A

# Формирование матрицы F
def form_matrix_F(C, E):
    # Сумма элементов в областях
    sum_area2 = 0
    sum_area4 = 0
    sum_area1 = 0
    sum_area3 = 0
    n = len(C)

    # Вычисление сумм элементов в областях
    for i in range(n):
        for j in range(n):
            # Область 2
            if i >= n // 2 and j < n // 2:
                sum_area2 += C[i][j]
            # Область 4
            elif i < n // 2 and j >= n // 2:
                sum_area4 += C[i][j]

    # Условие
    if sum_area2 > sum_area4:
        for i in range(n // 2):
            C[i][:i], C[n - i - 1][:n - i - 1] = C[n - i - 1][:n - i - 1], C[i][:i] # Поменять в C симметрично области 1 и 3
    else:
        C, E = E, C # Поменять C и E местами несимметрично

    return C

# Вычисление выражения (F+A)*AT - K * F
def calculate_F(F, A, AT, K):
    result_matrix = [[(F[i][j] + A[i][j]) * AT[i][j] - K * F[i][j] for j in range(len(F))] for i in range(len(F))]
    return result_matrix

def main():
    K = int(input("Введите число K: "))
    N = int(input("Введите размер матрицы N: "))

    # Генерация матрицы A(N,N) и ее подматриц B, C, D, E
    A = generate_matrix(N)
    print("\nМатрица A:")
    for row in A:
        print(row)

    # Создание матриц B, C, D, E
    B = [row[0:N//2] for row in A[0:N//2]]
    C = [row[N//2:] for row in A[0:N//2]]
    D = [row[0:N//2] for row in A[N//2:]]
    E = [row[N//2:] for row in A[N//2:]]

    # Формирование матрицы F
    F = form_matrix_F(C, E)
    print("\nМатрица F:")
    for row in F:
        print(row)

    # Вычисление выражения (F+A)*AT - K * F
    AT = [[row[i] for row in F] for i in range(len(F))]
    result_matrix = calculate_F(F, A, AT, K)

    # Вывод результатов
    print("\nРезультат выражения (F+A)*F – K * F:")
    for row in result_matrix:
        print(row)
main()
